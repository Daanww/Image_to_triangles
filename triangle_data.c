#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <SDL.h>
#include <SDL2_gfxPrimitives.h>
//#include "triangle_data.h"

#define N_POSITIONS 10
#define EDGE_CUTOFF_PERCENTAGE 10

typedef struct Coordinate
{
	int x;
	int y;
} coordinate;


//p1,p2,p3 represent indexes in a positions array
typedef struct Triangle
{
	int p1;
	int p2;
	int p3;
	SDL_Color c;
} triangle;

extern int SCREEN_WIDTH;
extern int SCREEN_HEIGHT;
extern coordinate positions[N_POSITIONS];
extern triangle triangles[N_POSITIONS*N_POSITIONS];
extern int n_triangles;

//generates a set of positions which it stores in the positions array
//this set of positions is valid for the given SCREEN_WIDTH and SCREEN_HEIGHT thus they are within the rectangle specified by (0,SCREEN_HEIGHT) and (SCREEN_WIDTH, 0)
//it is also guaranteed to include the 4 corners to make sure that the triangulation of these positions results in a proper rectangle
//returns true if generation as successfull and returns false otherwise.
bool generate_positions()
{

	//bool for tracking success of the operation
	bool success = true;

	if (N_POSITIONS < 4)
	{
		printf("Could not generate positions for triangulation because the number of positions was <4");
		success = false;
		return success;
	}

	coordinate temp = {0, SCREEN_HEIGHT - 1};

	//first we add the corners
	positions[0] = temp;
	temp.x = SCREEN_WIDTH - 1;
	positions[1] = temp;
	temp.y = 0;
	positions[2] = temp;
	temp.x = 0;
	positions[3] = temp;

	//then we distribute the rest of the points
	//if any points are located too close to the edge, within the EDGE_CUTOFF_PERCENTAGE, then they are put on the edge of the rectangle
	int x_coordinate = 0;
	int y_coordinate = 0;

	for (int i = 4; i < N_POSITIONS; i++)
	{
		//generate a x and y
		x_coordinate = rand() % SCREEN_WIDTH;
		y_coordinate = rand() % SCREEN_HEIGHT;

		//make sure the x and y are put on the edges if they're close to them
		if (x_coordinate <= (SCREEN_WIDTH / 100 * EDGE_CUTOFF_PERCENTAGE))
		{
			x_coordinate = 0;
		}
		else if (x_coordinate >= (SCREEN_WIDTH - (SCREEN_WIDTH / 100 * EDGE_CUTOFF_PERCENTAGE)))
		{
			x_coordinate = SCREEN_WIDTH - 1;
		}
		else if (y_coordinate <= (SCREEN_HEIGHT / 100 * EDGE_CUTOFF_PERCENTAGE))
		{
			y_coordinate = 0;
		}
		else if (y_coordinate >= (SCREEN_HEIGHT - (SCREEN_HEIGHT / 100 * EDGE_CUTOFF_PERCENTAGE)))
		{
			y_coordinate = SCREEN_HEIGHT - 1;
		}

		//add the position to the array
		positions[i].x = x_coordinate;
		positions[i].y = y_coordinate;
	}

	return success;
}


//after the positions array has been filled, this functions will store the positions in a file in a suitable format for the triangle library
//the triangle library can then read this file and triangulate the points
//name is a string which is used for the file_name
bool write_positions_to_file(char* name) {

	bool success = true;

	//first check if the name is not too long
	if(strlen(name) > 250) {
		success = false;
		printf("ERROR: Could not make a file to hold the positions because the supplied name as too long! (>250 char)\n");
		return success;
	}
	char file_name[256] = {0};
	sprintf(file_name, "%s.node", name);

	//try to make the file
	FILE* file = 0;
	file = fopen(file_name,"w");
	if(file == NULL) {
		success = false;
		printf("ERROR: Could not make file for storing positions! (A NULL pointer was returned by fopen()\n");
		return success;
	}

	//add some prelimenary information to the file
	char temp_string[512] = {0};
	sprintf(temp_string, "# %s\n", file_name);
	fputs(temp_string, file);
	sprintf(temp_string, "# A set of %i points in 2D, no attributes, no boundary markers\n", N_POSITIONS);
	fputs(temp_string, file);
	sprintf(temp_string, "%i  2  0  0\n", N_POSITIONS);
	fputs(temp_string, file);
	sprintf(temp_string, "# And here are the %i points.\n", N_POSITIONS);
	fputs(temp_string, file);
	sprintf(temp_string, "# Formatted as following: \"n x y\" with x moving positive from left to right and y moving positive from down to up\n");
	fputs(temp_string, file);

	//now for the coordinates themselves
	for(int i = 0; i < N_POSITIONS; i++) {
		sprintf(temp_string, "%i  %i  %i\n", i, positions[i].x, positions[i].y);
		fputs(temp_string, file);
	}

	//closing statement
	sprintf(temp_string, "# This file was automatically generated by the function write_positions_to_file()\n");
	fputs(temp_string, file);

	fclose(file);

	return success;


}


//this returns the triangle that is contained in the line parameter
//with this line we mean a line extracted from a .ele file generated by the triangle library
//it is assumed the line is formatted in the following way: "n  a  b  c" with n=identifier of the triangle and a,b,c are the positions that it is madde from
//if a triangle could not be identified in the line then a triangle which contains 3 NULL pointers is returned.
triangle get_triangle_from_line(char* line) {

	//the triangle
	triangle _triangle = {0,0,0};

	//index in the line string
	int index = 0;

	//skip the identifier of the triangle because we dont care about that

	//first skip whitespace
	while(line[index] == ' ') {
		index++;
	}
	//skip identifier
	while(line[index] != ' ') {
		index++;
	}

	//skip whitespace
	while(line[index] == ' ') {
		index++;
	}
	//save the beginning of the first number
	int begin_index = index;
	//skip untill we hit whitespace again
	while(line[index] != ' ') {
		index++;
	}
	char number_string[128] = {0};
	strncpy(number_string, (line+begin_index), index-begin_index);
	number_string[index-begin_index] = '\0';
	int position_index = atoi(number_string);
	_triangle.p1 = position_index;

	//skip whitespace
	while(line[index] == ' ') {
		index++;
	}
	//save the beginning of second the number
	begin_index = index;
	//skip untill we hit whitespace again
	while(line[index] != ' ') {
		index++;
	}
	strncpy(number_string, (line+begin_index), index-begin_index);
	number_string[index-begin_index] = '\0';
	position_index = atoi(number_string);
	_triangle.p2 = position_index;

	//skip whitespace
	while(line[index] == ' ') {
		index++;
	}
	//save the beginning of third the number
	begin_index = index;
	//skip untill we hit whitespace again
	while(line[index] != ' ' && line[index] != '\n') {
		index++;
	}
	strncpy(number_string, (line+begin_index), index-begin_index);
	number_string[index-begin_index] = '\0';
	position_index = atoi(number_string);
	_triangle.p3 = position_index;




	return _triangle;

}

//This function uses the triangle application which is contained in the build folder to make a triangulation of the positions writen to a file by write_positions_to_file
bool generate_triangles_file(char *name) {
	char command[512] = {0};
	sprintf(command, "./triangle %s", name);
	if(system(command) == -1)
		return false;

	return true;
	
}

//This function reads the triangles from the file generated by the triange library. The parameter name is assumed to be the same string as used by the write_positions_to_file function to setup the positions
//It stores the triangles in the triangles array
bool read_triangles_from_file(char* name) {

	bool success = true;

	//first check if the name is not too long
	if(strlen(name) > 250) {
		success = false;
		printf("ERROR: Could not make a file to hold the positions because the supplied name as too long! (>250 char)\n");
		return success;
	}
	char file_name[256] = {0};
	sprintf(file_name, "%s.1.ele", name);

	//try to open the file
	FILE* file = NULL;
	file = fopen(file_name,"r");
	if(file == NULL) {
		success = false;
		printf("ERROR: Could not open file for reading the triangles! (A NULL pointer was returned by fopen()\n");
		return success;
	}

	//get first line from file, this contains the amount of triangles that the file contains.
	char line[512] = { 0 };
	fgets(line, 512, file);
	int number_of_triangles = atoi(line);
	n_triangles = number_of_triangles;

	//get all triangles and store them in the triangles array
	for(int i = 0; i < number_of_triangles; i++) {
		fgets(line, 512, file);
		triangles[i] = get_triangle_from_line(line);
	}
	fclose(file);

	return success;


}


//generates initial colours for the triangles array
//these are fully random
void generate_triangle_colours() {

	SDL_Color c = {0,0,0,255};

	for(int i = 0; i < n_triangles; i++) {
		
		//return if we run out of triangles in the triangles array
		if(triangles[i].p1 == 0 && triangles[i].p2 == 0 && triangles[i].p3 == 0) {
			return;
		}

		//generate some random colours	
		c.r = rand() % 256;
		c.g = rand() % 256;
		c.b = rand() % 256;
		triangles[i].c = c;
	}

	return;
}


//blits all the triangles of _positions to the screen
void blit_triangles(SDL_Renderer* renderer, coordinate *_positions) {
	
	for(int i = 0; i < n_triangles; i++) {

		//return if we run out of triangles in the triangles array
		if(triangles[i].p1 == 0 && triangles[i].p2 == 0 && triangles[i].p3 == 0) {
			return;
		}

		filledTrigonRGBA(renderer, _positions[triangles[i].p1].x+SCREEN_WIDTH, _positions[triangles[i].p1].y, _positions[triangles[i].p2].x+SCREEN_WIDTH, _positions[triangles[i].p2].y, _positions[triangles[i].p3].x+SCREEN_WIDTH, _positions[triangles[i].p3].y, triangles[i].c.r, triangles[i].c.g, triangles[i].c.b, triangles[i].c.a);
	}

	return;
}



